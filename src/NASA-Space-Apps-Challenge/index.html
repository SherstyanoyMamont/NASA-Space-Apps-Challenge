<!doctype html>
<html>

<!-- ---------------------------------------------------------------------------------------------- -->
<!-- -- HEAD -------------------------------------------------------------------------------------- -->
<!-- ---------------------------------------------------------------------------------------------- -->


<head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <style>
        html,
        body,
        #map {
                height: 100%;
                margin: 0;
                padding: 0
        }

        .ctl {
                position: absolute;
                top: 12px;
                left: 12px;
                z-index: 5;
                background: rgba(32, 32, 32, .65);
                color: #fff;
                border-radius: 10px;
                padding: 10px 12px;
                backdrop-filter: saturate(1.2) blur(2px);
                font: 14px/1.2 system-ui, Segoe UI, Roboto, Helvetica, Arial
        }

        .ctl input[type=range] {
                width: 220px
        }

        .ctl .val {
                display: inline-block;
                min-width: 36px;
                text-align: right;
                margin-left: 6px
        }
    </style>

    <script src='https://maps.googleapis.com/maps/api/js?key=__GOOGLE_API_KEY__&libraries=visualization&language=en'></script>

</head>

<!-- ---------------------------------------------------------------------------------------------- -->
<!-- -- BODY -------------------------------------------------------------------------------------- -->
<!-- ---------------------------------------------------------------------------------------------- -->



<body>


    <div style=" position:absolute;right:12px;bottom:12px;z-index:5; padding:6px
        10px;border-radius:8px;background:rgba(32,32,32,.6);color:#fff; font:12px system-ui">
        <div style=" margin-bottom:4px">Bloom intensity (low→high):</div>
        <div style=" width:200px;height:10px; background:linear-gradient(90deg, #12206e 0%, #1950c8 15%, #1ec0dc 30%,
            #28aa5a 45%, #c8d23c 60%, #f0a83c 75%, #eb503c 90%, #b4141e 100%); border-radius:4px"></div>
    </div>


    <div id='map'></div>


    <div class='ctl'>
        <label>Bloom map opacity:
            <input id='op' type='range' min='0' max='1' step='0.01' value='0.55'>
            <span id='opv' class='val'>0.55</span>
        </label>
    </div>


    <!-- ---------------------------------------------------------------------------------------------- -->
    <!-- -- SCRIPT ------------------------------------------------------------------------------------ -->
    <!-- ---------------------------------------------------------------------------------------------- -->



    <script>


        let map, overlay, heatLayer;
        let pendingOpacity = parseFloat(localStorage.getItem('ndviOpacity') || '0.55');
        let tileVersion = 1;          // для инвалидации кэша (?v=)
        let hoverRect = null;       // рамка под курсором
        let selectedRect = null;    // зафиксированный диапазон (ПКМ)
        let bakeTimer = null;         // debounce тайл-вычисления
        let curBboxKey = null;        // текущий набор тайлов
        let curDateKey = null;

        function setBakeContext(bboxKey, dateKey) { curBboxKey = bboxKey; curDateKey = dateKey; }

        // ---------- утилиты тайлов WebMercator ----------
        function latLngToTileXY(lat, lng, z) {
            const n = Math.pow(2, z);
            const x = Math.floor((lng + 180.0) / 360.0 * n);
            const y = Math.floor((1.0 - Math.log(Math.tan(lat * Math.PI / 180.0) + 1 / Math.cos(lat * Math.PI / 180.0)) / Math.PI) / 2.0 * n);
            return { x, y };
        }

        function tileBounds(z, x, y) {
            const n = Math.pow(2, z);
            const lon1 = x / n * 360.0 - 180.0;
            const lat1 = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180.0 / Math.PI;
            const lon2 = (x + 1) / n * 360.0 - 180.0;
            const lat2 = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180.0 / Math.PI;
            return { west: lon1, south: lat2, east: lon2, north: lat1 }
        }

        function showTileFrame(z, x, y) {
            const b = tileBounds(z, x, y);
            const opts = {
                strokeColor: '#00FFFF',
                strokeOpacity: 1,
                strokeWeight: 2,
                fillOpacity: 0,
                map,
                bounds: { north: b.north, south: b.south, east: b.east, west: b.west }
            };
            if (!hoverRect) hoverRect = new google.maps.Rectangle(opts);
            else hoverRect.setOptions(opts);
        }

        function hideHoverFrame() {
            if (hoverRect) { hoverRect.setMap(null); hoverRect = null; }
        }

        // фиксированная рамка (диапазон)
        function showSelectedFrame(bounds) {
            // bounds: {west,east,south,north}
            const opts = {
                strokeColor: '#00FFD1',
                strokeOpacity: 1,
                strokeWeight: 2,
                fillOpacity: 0,
                map,
                bounds: { north: bounds.north, south: bounds.south, east: bounds.east, west: bounds.west }
            };
            if (selectedRect) selectedRect.setMap(null);
            selectedRect = new google.maps.Rectangle(opts);
        }

        function flashSelected() {
            if (!selectedRect) return;
            const prev = selectedRect.get('strokeColor');
            selectedRect.setOptions({ strokeColor: '#FFEA00', strokeWeight: 3 });
            setTimeout(() => selectedRect && selectedRect.setOptions({ strokeColor: prev, strokeWeight: 2 }), 180);
        }

        function postToHost(obj) {
            try { window.chrome?.webview?.postMessage(JSON.stringify(obj)); } catch (e) { console.error(e); }
        }

        // ---------- управление тайловым слоем + опацити ----------
        function applyOpacityToTiles() {
            const root = map.getDiv();
            // жёстко фильтруем по origin и префиксу нашего слоя
            const prefix = `${location.origin}/${curBboxKey}/${curDateKey}/z/`;
            const imgs = Array.from(root.querySelectorAll('img'))
                .filter(img => {
                    try {
                        const u = new URL(img.src, location.href);
                        return u.origin === location.origin && u.pathname.startsWith(`/${curBboxKey}/${curDateKey}/z/`);
                    } catch { return false; }
                });
            imgs.forEach(img => { img.style.opacity = pendingOpacity.toFixed(2); });
        }

        // helper: объединённые границы по диапазону тайлов
        function tileRangeBounds(z, x0, x1, y0, y1) {
            const b0 = tileBounds(z, Math.min(x0, x1), Math.min(y0, y1));
            const b1 = tileBounds(z, Math.max(x0, x1), Math.max(y0, y1));
            // b1.east/south нужно взять у ""следующего"" тайла по правому/нижнему краю
            const bE = tileBounds(z, Math.max(x0, x1) + 1, Math.min(y0, y1));
            const bS = tileBounds(z, Math.min(x0, x1), Math.max(y0, y1) + 1);
            return { west: b0.west, east: bE.west, north: b0.north, south: bS.south };
        }

        function addTileLayer(bboxKey, dateKey) {
            curBboxKey = bboxKey;
            curDateKey = dateKey;

            if (overlay) { overlay.setMap(null); overlay = null; }
            if (heatLayer) {
                const idx = map.overlayMapTypes.getArray().indexOf(heatLayer);
                if (idx >= 0) map.overlayMapTypes.removeAt(idx);
                heatLayer = null;
            }

            heatLayer = new google.maps.ImageMapType({
                tileSize: new google.maps.Size(256, 256),
                opacity: pendingOpacity,                      // <— только так
                getTileUrl: (coord, zoom) => {
                    const n = 1 << zoom;
                    const x = ((coord.x % n) + n) % n;
                    const y = coord.y;
                    if (y < 0 || y >= n) return null;
                    return `/${bboxKey}/${dateKey}/z/${zoom}/${x}/${y}.png?v=${tileVersion}`;
                }
            });

            map.overlayMapTypes.insertAt(0, heatLayer);
        }


        function resetForeignImgOpacity() {
            const root = map.getDiv();
            const prefix = `/${curBboxKey}/${curDateKey}/z/`;  // наши тайлы
            root.querySelectorAll('img').forEach(img => {
                try {
                    const u = new URL(img.src, location.href);
                    const isOurs = (u.origin === location.origin) && u.pathname.startsWith(prefix);
                    if (!isOurs) img.style.opacity = '';          // <— снять чужое
                } catch { }
            });
        }

        // ---------- (на всякий) режим единого PNG-оверлея ----------
        function addOverlayPng(pngUrl, bbox) {

            const b = Array.isArray(bbox) ?
                { minLon: bbox[0], minLat: bbox[1], maxLon: bbox[2], maxLat: bbox[3] } : bbox;

            const imageBounds = {
                south: b.minLat, west: b.minLon, north: b.maxLat, east: b.maxLon
            };

            if (overlay) overlay.setMap(null);

            overlay = new google.maps.GroundOverlay(pngUrl, imageBounds, { opacity: pendingOpacity });
            overlay.setMap(map);
            map.fitBounds(new google.maps.LatLngBounds(
                new google.maps.LatLng(imageBounds.south, imageBounds.west),
                new google.maps.LatLng(imageBounds.north, imageBounds.east)
            ));
        }

        function init() {

            map = new google.maps.Map(
                document.getElementById('map'),
                {
                    center: { lat: 52.675, lng: 5.80 },
                    zoom: 12,
                    mapTypeId: 'hybrid',
                    mapTypeControl: false, fullscreenControl: false, streetViewControl: false,
                    zoomControl: false, rotateControl: false, scaleControl: false
                }
            );

            map.getDiv().addEventListener('contextmenu', e => e.preventDefault());

            const op = document.getElementById('op');
            const opv = document.getElementById('opv');


            // Слайдер — меняем opacity только на heatLayer и чистим чужие остатки
            const apply = (v) => {
                pendingOpacity = v;
                localStorage.setItem('ndviOpacity', String(v));
                if (heatLayer && typeof heatLayer.setOpacity === 'function') {
                    heatLayer.setOpacity(v);
                }
                if (overlay) overlay.setOpacity(v);
                resetForeignImgOpacity();                        // <— важный вызов
            };

            op.value = pendingOpacity.toFixed(2);
            opv.textContent = op.value;

            op.addEventListener('input', () => {
                const v = parseFloat(op.value);
                opv.textContent = v.toFixed(2);
                apply(v);
            });

            apply(pendingOpacity);

            map.addListener('mousemove', (ev) => {
                const z = map.getZoom();
                if (z == null) return;

                const { x, y } = latLngToTileXY(ev.latLng.lat(), ev.latLng.lng(), z);
                showTileFrame(z, x, y);

                if (curBboxKey && curDateKey) {
                    clearTimeout(bakeTimer);
                    bakeTimer = setTimeout(() => {
                        postToHost({ type: 'bakeTile', bboxKey: curBboxKey, dateKey: curDateKey, z, x, y });
                    }, 250);
                }
            });

            map.addListener('zoom_changed', () => hideHoverFrame());
            map.addListener('dragstart', () => hideHoverFrame());

            map.addListener('rightclick', (ev) => {
                const z = map.getZoom();
                if (z == null) return;

                const { x, y } = latLngToTileXY(ev.latLng.lat(), ev.latLng.lng(), z);

                const R = (ev.domEvent || {}).ctrlKey ? 2 : ((ev.domEvent || {}).shiftKey ? 1 : 0);
                const x0 = x - R, x1 = x + R, y0 = y - R, y1 = y + R;

                const rb = tileRangeBounds(z, x0, x1, y0, y1);
                showSelectedFrame(rb);

                if (curBboxKey && curDateKey) {
                    postToHost({ type: 'bakeRegion', bboxKey: curBboxKey, dateKey: curDateKey, z, x0, x1, y0, y1 });
                }
            });

        }

        init();

        if (!window.__webviewHandlerBound) {
            window.__webviewHandlerBound = true;
            window.chrome?.webview?.addEventListener('message', (e) => {
                try {
                    const msg = JSON.parse(e.data);
                    switch (msg.type) {
                        case 'overlay':
                            addOverlayPng(msg.url, msg.bbox);
                            break;
                        case 'tileLayer':
                            addTileLayer(msg.bboxKey, msg.dateKey);
                            break;
                        case 'bakeContext':
                            setBakeContext(msg.bboxKey, msg.dateKey);
                            break;
                        case 'tileReady': {
                            // инвалидация тайлов
                            tileVersion++;
                            const arr = map.overlayMapTypes.getArray();
                            const idx = arr.indexOf(heatLayer);
                            if (idx >= 0) {
                                map.overlayMapTypes.removeAt(idx);
                                map.overlayMapTypes.insertAt(idx, heatLayer);
                            }
                            // мягко мигнём именно фиксированной рамкой (если есть)
                            flashSelected();
                            break;
                        }
                        default:
                            console.warn('Unknown message from host:', msg);
                    }
                } catch (err) {
                    console.error('WebView message parse/handle error:', err, e.data);
                }
            });

        }

    </script>

</body>

</html>